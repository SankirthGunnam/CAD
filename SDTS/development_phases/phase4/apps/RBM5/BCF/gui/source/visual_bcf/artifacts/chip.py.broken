"""
Component with Pins Module - Phase 2.5

Enhanced component with visible pins for connections.
"""

from PySide6.QtCore import QPointF, Qt, QTimer
from PySide6.QtGui import QPen, QBrush, QColor, QFont
from PySide6.QtWidgets import (

    QGraphicsRectItem, QGraphicsTextItem, QMenu, QMessageBox, QGraphicsItem)

from apps.RBM5.BCF.gui.source.visual_bcf.artifacts.pin import ComponentPin


class ComponentWithPins(QGraphicsRectItem):
    """Enhanced component with visible pins for connections"""

    def __init__(
            self,
            name: str,
            component_type: str,
            width: float = 100,
            height: float = 60):
        super().__init__(0, 0, width, height)

        # Component properties
        self.name = name
        self.component_type = component_type
        self.is_selected = False
        self.pins = []  # List of ComponentPin objects
        self.connected_wires = []  # List of wires connected to this component

        # Visual properties
        self.setFlag(self.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(self.GraphicsItemFlag.ItemIsSelectable, True)
        self.setFlag(self.GraphicsItemFlag.ItemSendsScenePositionChanges, True)

        # Set appearance and create pins based on type
        self._setup_appearance()
        self._create_pins()

        # Add centered text label
        self.text_item = QGraphicsTextItem(name, self)
        self.text_item.setFont(QFont("Arial", 8))
        # Center the text properly
        text_rect = self.text_item.boundingRect()
        self.text_item.setPos(
            (width - text_rect.width()) / 2,
            (height - text_rect.height()) / 2
        )

    def _create_pins(self):
        """Create pins based on component type with comprehensive layouts"""
        width = self.rect().width()
        height = self.rect().height()
        pin_radius = 4  # Pin radius for centering calculations

        if self.component_type == "chip":
            # Comprehensive chip: 6 pins on each side (24 total)
            side_pins = 6
            top_bottom_pins = 6

            # Vertical spacing for left/right pins
            pin_spacing_vertical = height / (side_pins + 1)
            # Horizontal spacing for top/bottom pins
            pin_spacing_horizontal = width / (top_bottom_pins + 1)

            # Left side pins (inputs) - perfectly centered on left edge
            input_names = ["DATA_IN", "CLK", "RST", "EN", "CS", "WR"]
            for i in range(side_pins):
                pin_name = input_names[i] if i < len(
                    input_names) else f"IN{i + 1}"
                pin = ComponentPin(f"L{i + 1}", pin_name,
                                   "input", self, "left")
                pin.setParentItem(self)
                # Position pin so half extends outside left edge (x=0)
                pin.setPos(-pin_radius,
                           pin_spacing_vertical * (i + 1) - pin_radius)
                self.pins.append(pin)

            # Right side pins (outputs) - perfectly centered on right edge
            output_names = ["DATA_OUT", "INT", "RDY", "ACK", "ERR", "STAT"]
            for i in range(side_pins):
                pin_name = output_names[i] if i < len(
                    output_names) else f"OUT{i + 1}"
                pin = ComponentPin(f"R{i + 1}", pin_name,
                                   "output", self, "right")
                pin.setParentItem(self)
                # Position pin so half extends outside right edge (x=width)
                pin.setPos(width - pin_radius,
                           pin_spacing_vertical * (i + 1) - pin_radius)
                self.pins.append(pin)

            # Top pins (power/control) - perfectly centered on top edge
            top_names = ["VDD", "VREF", "AVDD", "DVDD", "NC", "TEST"]
            for i in range(top_bottom_pins):
                pin_name = top_names[i] if i < len(
                    top_names) else f"VCC{i + 1}"
                pin_type = "power" if "VDD" in pin_name or "V" in pin_name else "io"
                pin = ComponentPin(f"T{i + 1}", pin_name,
                                   pin_type, self, "top")
                pin.setParentItem(self)
                # Position pin so half extends outside top edge (y=0)
                pin.setPos(pin_spacing_horizontal *
                           (i + 1) - pin_radius, -pin_radius)
                self.pins.append(pin)

            # Bottom pins (ground/control) - perfectly centered on bottom edge
            bottom_names = ["GND", "AGND", "DGND", "VSS", "BIAS", "SHDN"]
            for i in range(top_bottom_pins):
                pin_name = bottom_names[i] if i < len(
                    bottom_names) else f"GND{i + 1}"
                pin_type = "gnd" if "GND" in pin_name or "VSS" in pin_name else "io"
                pin = ComponentPin(f"B{i + 1}", pin_name,
                                   pin_type, self, "bottom")
                pin.setParentItem(self)
                # Position pin so half extends outside bottom edge (y=height)
                pin.setPos(pin_spacing_horizontal * (i + 1) -
                           pin_radius, height - pin_radius)
                self.pins.append(pin)

        elif self.component_type == "resistor":
            # Resistor: 2 pins (left and right) - centered on edges
            pin1 = ComponentPin("A", "A", "terminal", self, "left")
            pin1.setParentItem(self)
            pin1.setPos(-pin_radius, height / 2 - pin_radius)
            self.pins.append(pin1)

            pin2 = ComponentPin("B", "B", "terminal", self, "right")
            pin2.setParentItem(self)
            pin2.setPos(width - pin_radius, height / 2 - pin_radius)
            self.pins.append(pin2)

        elif self.component_type == "capacitor":
            # Capacitor: 2 pins (left and right) - centered on edges
            pin1 = ComponentPin("POS", "+", "positive", self, "left")
            pin1.setParentItem(self)
            pin1.setPos(-pin_radius, height / 2 - pin_radius)
            self.pins.append(pin1)

            pin2 = ComponentPin("NEG", "-", "negative", self, "right")
            pin2.setParentItem(self)
            pin2.setPos(width - pin_radius, height / 2 - pin_radius)
            self.pins.append(pin2)

    def _setup_appearance(self):
        """Set visual appearance based on component type"""
        if self.component_type == "chip":
            self.setBrush(QBrush(QColor(100, 150, 200)))  # Blue
            self.setPen(QPen(QColor(50, 100, 150), 2))
        elif self.component_type == "resistor":
            self.setBrush(QBrush(QColor(200, 150, 100)))  # Brown
            self.setPen(QPen(QColor(150, 100, 50), 2))
        elif self.component_type == "capacitor":
            self.setBrush(QBrush(QColor(150, 200, 100)))  # Green
            self.setPen(QPen(QColor(100, 150, 50), 2))
        else:
            self.setBrush(QBrush(QColor(180, 180, 180)))  # Gray
            self.setPen(QPen(QColor(120, 120, 120), 2))

    def contextMenuEvent(self, event):
        """Show context menu on right click"""
        menu = QMenu()

        # Add properties action
        properties_action = menu.addAction("Properties")
        delete_action = menu.addAction("Delete")

        action = menu.exec(event.screenPos())

        if action == properties_action:
            self._show_properties()
        elif action == delete_action:
            self._delete_component()

    def _show_properties(self):
        """Show component properties dialog"""
        QMessageBox.information(
            None,
            f"{self.name} Properties",
            f"Name: {self.name}\n"
            f"Type: {self.component_type}\n"
            f"Position: ({self.x():.1f}, {self.y():.1f})\n"
            f"Size: {self.rect().width()}x{self.rect().height()}"
        )

    def _delete_component(self):
        """Delete this component"""
        if hasattr(self.scene(), 'remove_component'):
            self.scene().remove_component(self)
        else:
            self.scene().removeItem(self)

    def add_wire(self, wire):
        """Add a wire connection to this component"""
        if wire not in self.connected_wires:
            self.connected_wires.append(wire)

    def remove_wire(self, wire):
        """Remove a wire connection from this component"""
        if wire in self.connected_wires:
            self.connected_wires.remove(wire)

    def update_connected_wires(self):
        """Update all connected wires when component moves"""
        for wire in self.connected_wires:
            if hasattr(wire, 'update_wire_position_dragging'):
                # Use dragging-aware update for better performance
                wire.update_wire_position_dragging()
            elif hasattr(wire, 'update_wire_position_lightweight'):
                # Fallback to lightweight update
                wire.update_wire_position_lightweight()
            elif hasattr(wire, 'update_path'):
                wire.update_path()
            elif hasattr(wire, 'update_line'):
                wire.update_line()  # Fallback for old wire types
    
    def update_connected_wires_full(self):
        """Force full update of all connected wires (use after placement is complete)"""
        for wire in self.connected_wires:
            if hasattr(wire, 'update_wire_position_final'):
                # Use final position update for complete recalculation
                wire.update_wire_position_final()
            elif hasattr(wire, 'update_path'):
                wire.update_path()
            elif hasattr(wire, 'update_line'):
                wire.update_line()  # Fallback for old wire types

    def itemChange(self, change, value):
        """Handle item changes, particularly position changes"""
        if change == QGraphicsItem.GraphicsItemChange.ItemPositionChange:
            # Don't update wires during dragging - only update on final position
            # This prevents performance issues during mouse movement
            pass

        elif change == QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged:
            # Update connected wires only after the move is complete
            # Use QTimer.singleShot to defer the update
            QTimer.singleShot(0, self.update_connected_wires)

            # Notify controller to sync model position (deferred)
            try:
                scene = self.scene()
                if scene and hasattr(scene, 'controller'):
                    controller = scene.controller
                    if (controller and
                        hasattr(controller, 'on_graphics_component_moved') and
                            callable(getattr(controller, 'on_graphics_component_moved', None))):

                        QTimer.singleShot(
                            0, lambda: self._notify_controller_position_change(controller))

            except Exception as e:
                print(f"Warning: Could not notify controller of position change: {e}")

        return super().itemChange(change, value)

    def _notify_controller_position_change(self, controller):
        """Safely notify controller of position change"""
        try:
            if controller and hasattr(
                    controller, 'on_graphics_component_moved'):
                controller.on_graphics_component_moved(self)
        except Exception as e:
            print(f"Error notifying controller of position change: {e}")
    
    def mouseReleaseEvent(self, event):
        """Handle mouse release to trigger full wire updates after dragging"""
        super().mouseReleaseEvent(event)
        
        # After dragging is complete, do a full wire update
        # This ensures proper collision detection and routing
        QTimer.singleShot(100, self.update_connected_wires_full)
